```
<button type="button" @click="count+=1">点击</button><!--获取事件对象-->
<button @click="clickEvent">点击2</button>

```

完成事件绑定，两种都可以实现

## 事件传参

```html
<li v-for="item,index in stars" @click="clickEvent(index,item,$event)">index:索引值，，item：内容</li>

vue{
    methods:{
        clickEvent:function(index,item,event){
        log(index),
        log(item),
        log($event)
        }
    }
}
```

## 事件修饰符

.stop

.prevent

.capcure

.self

.once

.passive

# 表单输入绑定

表单value值的绑定不是靠绑定：value，而是靠绑定 **v-model**

> **`v-model`** 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

## 1.input

<img src="C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521151604606.png" alt="image-20210521151604606" style="zoom: 50%;" />

### 原理

1.v-bind绑定一个value属性
2.v-on指令给当前元素绑定input事件

<input type="text" v-model="message">
等同于
<input type="text" v-bind:value="message" v-on:input="message = $event.target.value">

## 2.radio

![image-20210521161941698](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521161941698.png)

v-model绑定了sex后，name: 'sex' 可以没有----》这个作用是限制只能选一个 ------》互斥，，v-model也可以实现

## 3.CheckBox

复选框分为两种情况：单个勾选框和多个勾选框

### 单个勾选框：

v-model即为布尔值。
此时input的value并不影响v-model的值。



```html
<input type="checkbox" v-model="isagree">同意协议
<button :disabled="! isagree">下一步</button>
data:{isAgree:false}
```

​	同意了就可以点下一步

### 多个复选框：

当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。
当选中某一个时，就会将input的value添加到数组中。

![image-20210521162422324](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521162422324.png)

![image-20210521162439995](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521162439995.png)

将绑定到数组里面！！！

## 4.select

和checkbox一样，select也分单选和多选两种情况。

**v-model只能绑定在select上！！**

### 单选：只能选中一个值。

v-model绑定的是一个值。
当我们选中option中的一个时，会将它对应的value赋值到mySelect中

### 多选：可以选中多个值。

v-model绑定的是一个**数组**。
当选中多个值时，就会将选中的option对应的value添加到数组mySelects中

![image-20210521163347191](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521163347191.png)

![image-20210521163353756](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521163353756.png)

![image-20210521163359585](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521163359585.png)

## 5.值绑定

```html
<label v-for="item in originHobbies" :for="item">
<input type="checkbox" :value="item" :id="item" v-model="hobbies">{{item}}</label>
</div>
```

**动态的给value赋值：**
-我们前面的value中的值，可以回头去看一下，都是在定义input的时候直接给定的。
-但是真实开发中，这些input的值可能是从网络获取或定义在data中的。
-所以我们可以通过v-bind:value动态的给value绑定值。
这不就是v-bind吗？
-这不就是v-bind在input中的应用吗？搞的我看了很久，搞不清他想讲什么。
-这里不再给出对应的代码，因为会用v-bind，就会值绑定的应用了。

## 6.修饰符

### lazy修饰符：

默认情况下，v-model默认是在input事件中同步输入框的数据的。
也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。
lazy修饰符可以让数据**在失去焦点或者回车时**才会更新：

### number修饰符：

默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。
但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。
number修饰符可以让在输入框中输入的内容自动转成数字类型：

### trim修饰符：

如果输入的内容首尾有很多空格，通常我们希望将其去除
trim修饰符可以过滤内容左右两边的空格

![image-20210521164520422](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521164520422.png)

# 组件化

## 1.注册组件的基本步骤

component：组件

template：模板

### 组件的使用分成三个步骤：

-创建组件构造器
-注册组件
-使用组件。

![image-20210521164917878](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521164917878.png)

![image-20210521164932104](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521164932104.png)

组建的标签名必须要使用单引号---》否则会报错

## 2.注册组件步骤解析

### 1.Vue.component()：

调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。
所以需要传递两个参数：1、注册组件的标签名 2、组件构造器

### 2.组件必须挂载在某个Vue实例下，否则它不会生效。（见下页）

我们来看下面我使用了三次<my-cpn></my-cpn>
而第三次其实并没有生效：

![image-20210522145358172](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522145358172.png)

## 3.全局组件和局部组件

### 1.全局组件

- 当我们通过调用**Vue.component()注册组件时，组件的注册是全局的**
  	**这意味着该组件可以在任意Vue示例下使用**。
  
- ![image-20210522145721609](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522145721609.png)

- ```html
  Vue.cpmponent('cpn',{`
  //模板内容
  `})
  ```

  > cpn为标签名，cpnC为模板名称，
  >
  > 在局部时，标签名与模板名称一样，可以用es6增强写法

### 2.局部组件

- 如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件
- ![image-20210522145726600](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522145726600.png)

## 4.父组件和子组件

在前面我们看到了组件树：
	组件和组件之间存在层级关系
	而其中一种非常重要的关系就是父子组件的关系
我们来看通过代码如何组成的这种层级关系：

![image-20210522151631273](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522151631273.png)

### 父子组件错误用法：

**以子标签的形式在Vue实例中使用**
	因为当子组件注册到父组件的components时，Vue会编译好父组件的模块
	该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）
	<child-cpn></child-cpn>是只能在父组件中被识别的。
	类似这种用法，<child-cpn></child-cpn>是会被浏览器忽略的。

## 5.注册组件

### 1.语法糖

<img src="C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522152200827.png" alt="image-20210522152200827" style="zoom:150%;" />

### 2.模板的分离写法

Vue提供了两种方案来定义HTML模块内容：
使用<script>标签

![image-20210522152728056](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522152728056.png)

使用<template>标签

![image-20210522152738334](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522152738334.png)

## 6.data属性

### Q：组件里可以访问Vue实例数据吗？

组件是一个单独功能模块的封装：
	这个模块有属于自己的HTML模板，也应该有属性自己的数据data。

![image-20210522153812010](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522153812010.png)

我们发现不能访问，而且即使可以访问，如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿。
	**结论：Vue组件应该有自己保存数据的地方。**

### 1.组件数据的存放

组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)
只是这个data属性**必须是一个函数**
而且这个函数**返回一个对象，对象内部保存着数据**

![image-20210522154006329](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522154006329.png)

data(){     }===data : function  () {     }

### 2.为什么是一个函数呢?

- 首先，如果不是一个函数，Vue直接就会报错。

- 其次，原因是在于Vue让**每个组件对象都返回一个新的对象**，因为如果是同一个对象的，组件在**多次使用**后会相互影响。

# 生命周期与组件生命周期

## 生命周期

![Vue 实例生命周期](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\lifecycle.png)

![组件生命周期](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\组件生命周期.png)

### 1.beforeCreate()

此时数据data和事件方法methods还未绑定到app对象上

### 2.created()

数据data和方法methods绑定到应用对象app上，，完成初始化，，但只是拿到数据，还未绑定到页面上

### 3.beforeMount()

挂载前：渲染之前

根据数据生成的DOM对象是获取不到的

### 4.mounted()

渲染之后

根据数据生成的DOM对象是可以获取

### 5.beforeUpdate

数据更改，但内容未更改

### 6.updated

内容更改，已经更新完毕

### 7.beforeDestoy

销毁前

### 8.destoyed

解除绑定、销毁子组件以及事件监听器

## 组件生命周期

与生命周期一样

![image-20210521215556387](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210521215556387.png)

不show后就销毁

# 父子组件的通信 

```html
<div id="app">
    <ul>
      <school v-for="item,index in schoolList" :school-name="item" :key='index' :index='index' @cschool="changeEvent">
      </school>
    </ul>
    <h2>选中的学校是:{{chooseSchool}}</h2>
  </div>
  <script src="./js/vue.js"></script>
  <script>
    Vue.component("school", {
      props: ['schoolName', 'index'],
      template: `<li>
        <h3>{{index}}---学校名称{{schoolName}}</h3>
        <button @click="chooseEvent(schoolName)">选择学校</button>
      </li>`,
      methods: {
        chooseEvent: function (schoolName) {
          // 想要将子元素的数据传递给父元素，需要自定义触发事件，实现数据的传值
          // console.log(this);
          // 触发一个叫cSchool的事件,,触发了要监听----》将schoolName传过去
          this.$emit('cschool', schoolName); //
        }
      }
    })
    let app = new Vue({
      el: "#app",
      data: {
        schoolList: ['hyzx', 'zxzx', 'qhdx'],
        chooseSchool: '',
      },
      methods: {
        changeEvent: function (data) {
          this.chooseSchool = data;
        }
      }
    })
  </script>
```

在上一个小节中，我们提到了子组件是**不能引用父组件或者Vue实例的数据的**。

但是，在开发中，往往一些数据确实**需要从上层传递到下层**：
比如在一个页面中，我们从服务器请求到了很多的数据。

其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。

这个时候，并不会让子组件再次发送一个网络请求，而是**直接让大组件(父组件)将数据传递给小组件(子组件)**。

如何进行父子组件间的通信呢？Vue官方提到
	**通过props向子组件传递数据**（properties---》属性）
	**通过事件向父组件发送消息**（$emit）

![image-20210522160842560](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522160842560.png)

在下面的代码中，我直接将Vue实例当做父组件，并且其中包含子组件来简化代码。
真实的开发中，**Vue实例和子组件的通信和父组件和子组件的通信过程是一样的**。

## 1.一些写法注意点（自己总结）

<img src="C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522161427246.png" alt="image-20210522161427246" style="zoom:50%;" />=<img src="C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522161501763.png" alt="image-20210522161501763" style="zoom:50%;" />

**对象字面量**增强写法里的**属性增强写法**

![image-20210522161751307](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522161751307.png)

## 2.父传子props

props的值有两种方式：
	方式一：**字符串数组**，数组中的字符串就是传递时的名称。	

```html
<body>
  <div id="app">
    <cpn :cmovies="movies" :cmessage="message"> </cpn> 			--------》2222222，vue实例，必须要绑定组件里的。。。
  </div>
  <template id="cpn">
    <div>
      <ul>
        <li v-for="item in cmovies">{{item}}</li>      				-------》33333
      </ul>
      <p>{{cmessage}}</p>
    </div>
  </template>
  <script src="./js/vue.js"></script>
  <script>
    const cpn = {
      template: '#cpn',
      props: ['cmovies', 'cmessage'], //里面的东西当成变量          -----》111
      data() {
        return {}
      },
    }
    const app = new Vue({
      el: "#app",
      data: {
        message: "你好",
        movies: ['海尔', '222', '333']
      },
      components: {
        cpn //对象的增强写法 
        // = 'cpn': cpn,
        // //='cpn':{
        // 被定义成了cpn在上面
        // }
      }
    })
  </script>
</body>
```

​	方式二：**对象**，对象可以设置传递时的类型，也可以设置默认值等。

![image-20210522162117524](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522162117524.png)

### 1.props数据验证

在前面，我们的props选项是使用一个数组。

我们说过，除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了。
验证都支持哪些数据类型呢？

String
Number
Boolean
Array
Object
Date
Function
Symbol
当我们有自定义构造函数时，验证也支持自定义的类型

![image-20210522163035798](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210522163035798.png)

1.限制类型

![image-20210523144344961](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523144344961.png)

2.提供一些默认值，以及必传的值

![image-20210523144417503](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523144417503.png)

required：true，，，，必须传的值

//**类型是对象或者数组时,默认值必须是一个函数**

```html
cmovies:{
    type:Array,
    default:[  ]
}
```

这种会报错,,要和data一样

```
cmovies:{
    type:Array,
    default(){
    	return []
    }
}
```

### 2.props驼峰验证

v-bind不支持驼峰![image-20210523145757137](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523145757137.png)

**tips**：模板里包含很多 标签时  ，必须要有一个根，即一个div包含块 

## 3.子传父（自定义事件）

*什么时候需要自定义事件呢？*
	当子组件需要向父组件传递数据时，就要用到自定义事件了。
	我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。

*自定义事件的流程：*
	在子组件中，通过$emit()来触发事件。
	在父组件中，通过v-on来监听子组件事件。

![image-20210523154702023](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523154702023.png)

这个相当于点击事件里的event

*我们来看一个简单的例子：*
	我们之前做过一个两个按钮+1和-1，点击后修改counter。
	我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件。
	这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total。

![image-20210523154337541](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523154337541.png)

## 双向绑定案例

### **【注意】**

子组件最好不能直接修改父组件的值，只能父组件自己来修改自己的----》

在子组件中data或者computed里面定义

![image-20210523162320761](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523162320761.png)

## 4.父子组件的访问

有时候我们需要父组件**直接**访问子组件，子组件**直接**访问父组件，或者是子组件**访问跟组件**。

**父组件访问子组件**：使用$children或$refs(reference ;引用)

**子组件访问父组件**：使用$parent

### 1.$children（一般不用）

this.$children是一个数组类型，它包含所有子组件对象。
我们这里通过一个遍历，取出所有子组件的message状态。

【注意】：开发中一般不用，因为是循环拿到的 ，如果又增加了其他组件在里面会发生很大改变

![image-20210523215646605](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210523215646605.png)

#### $children的缺陷：

通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。
但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。
有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs

### 2.$refs的使用：

$refs和ref指令通常是一起使用的。

首先，我们通过ref给某一个子组件绑定一个特定的ID。
其次，通过this.$refs.ID就可以访问到该组件了。

![image-20210524145433003](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524145433003.png)

### 3.$parent

访问父组件

//返回对象VueComponment 对象

注意事项：
尽管在Vue开发中，但是**在真实开发中尽量不要这样做**。
子组件应该尽量避免直接访问父组件的数据，因为这样**耦合度**太高了。
如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题。
另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。

### 4.$root

访问根组件

//返回对象Vue

# 插槽

## 1.基本使用

如何去封装这类的组件呢？
	它们也很多区别，但是也有很多共性。
	如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装。
	但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等。

如何封装合适呢？抽取共性，保留不同。
	最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。
	一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。
	是搜索框，还是文字，还是菜单。由调用者自己来决定。

可以给定默认值，在调用时可以替换掉默认值

![image-20210524153953275](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524153953275.png)

## 2.具名插槽

![image-20210524155004130](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524155004130.png)

## 3.编译的作用域

官方对于编译的作用域解析比较简单，我们自己来通过一个例子来理解这个概念：
我们来考虑下面的代码是否最终是可以渲染出来的：
	<my-cpn v-show="isShow"></my-cpn>中，我们使用了isShow属性。
	isShow属性包含在组件中，也包含在Vue实例中。

答案：最终可以渲染出来，也就是使用的是Vue实例的属性。

为什么呢？
官方给出了一条准则：**父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。**
而我们在使用<my-cpn v-show="isShow"></my-cpn>的时候，整个组件的使用过程是相当于在父组件中出现的。、、、、类似于全局与局部作用域？？？
那么他的作用域就是父组件，使用的属性也是属于父组件的属性。

因此，**isShow使用的是Vue实例中的属性，而不是子组件的属性。**

## 4.作用域插槽

这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会：
	父组件替换插槽的标签，但是内容由子组件来提供。

我们先提一个需求：
子组件中包括一组数据，比如：pLanguages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++']
需要在多个界面进行展示：
	某些界面是以水平方向一一展示的，
	某些界面是以列表形式展示的，
	某些界面直接展示一个数组

内容在子组件，希望父组件告诉我们如何展示，怎么办呢？
	利用slot作用域插槽就可以了
我们来看看子组件的定义：

![image-20210524162048818](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524162048818.png)

在父组件使用我们的子组件时，从子组件中拿到数据：
	我们通过<template ********v-slot:default********="slotProps">获取到slotProps属性    //新版本跟以前语法不一样了
	在通过slotProps.data就可以获取到刚才我们传入的data了

![image-20210524162348649](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524162348649.png)

# 模块化开发

常见的模块化规范：
CommonJS、AMD、CMD，也有ES6的Modules

## 1.commonjs（了解）

模块化有两个核心：导出和导入

### CommonJS的导出：

![image-20210524195027642](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524195027642.png)

### CommonJS的导入

![image-20210524195040380](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524195040380.png)

## 2.ES6的Module

### 1.export

export指令用于导出变量，比如下面的代码：
![image-20210524195349457](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524195349457.png)

上面的代码还有另外一种写法：

![image-20210524195354997](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524195354997.png)

导出函数/类

![image-20210524201413457](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524201413457.png)

### 2.import

我们使用**export**指令导出了模块对外提供的接口，下面我们就可以通过import命令来加载对应的这个模块了

首先，我们需要在HTML代码中**引入两个js文件**，并且类型需要设置为**module**
![image-20210524202802291](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524202802291.png)

import指令用于导入模块中的内容，比如main.js的代码

![image-20210524202832956](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524202832956.png)

如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦：
	通过*可以导入模块中所有的export变量
	但是通常情况下我们需要给*起一个别名，方便后续的使用

![image-20210524202842543](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524202842543.png)

![](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524201514701.png)

### 3.export default

某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名
	这个时候就可以使用export default
![image-20210524201656470](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524201656470.png)
我们来到main.js中，这样使用就可以了
	这里的myFunc是我自己命名的，你可以根据需要命名它对应的名字
![image-20210524201704511](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524201704511.png)
另外，需要注意：
	**export default在同一个模块中，不允许同时存在多个。**

# webpack

## 1.配置文件

![image-20210525193606691](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210525193606691.png)

## 2.loader

![image-20210525194013176](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210525194013176.png)

安装：npm install --save- dev css-loader ts-loader

## 3. plugs

 npm install webpack-dev-server -g 热加载---》监听内容改变

# vue-cli

自动化构建工具

```
vue create project-one
```

## 1.什么是Vue Cli

CLI是什么意思?
	CLI是Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架.
	Vue CLI是一个官方发布 vue.js 项目脚手架
	使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置.

### 使用前提 **node**

安装NodeJS
	可以直接在官方网站中下载安装.
	网址: http://nodejs.cn/download/

什么是NPM呢?
	NPM的全称是Node Package Manager
	是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。
	后续我们会经常使用NPM来安装一些开发过程中依赖包.

cnpm安装
		由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。
	你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:
	npm install -g cnpm --registry=https://registry.npm.taobao.org
	这样就可以使用 cnpm 命令来安装模块了：
	cnpm install [name]

### 使用前提webpack

Vue.js官方脚手架工具就使用了webpack模板
	对所有的资源会压缩等优化操作
	它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效。

Webpack的全局安装
	npm install webpack -g

## 2.Vue Cli的使用

### 安装Vue脚手架

npm install -g @vue/cli
![image-20210524203556700](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524203556700.png)

注意：上面安装的是Vue CLI3的版本，如果需要想按照Vue CLI2的方式初始化项目时不可以的。
![image-20210524203604235](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524203604235.png)

### Vue CLI2初始化项目

​	vue init webpack my-project

### Vue CLI3初始化项目

​	vue create my-project

## 3.Vue Cli2详解

![image-20210524203648608](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524203648608.png)

## 4.目录结构详解

![image-20210524203707697](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524203707697.png)

## 5.Runtime-Compiler和Runtime-only的区别

如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler
如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only

![image-20210526155026675](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526155026675.png)

render：渲染

6.Vue程序运行过程

![image-20210526155529556](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526155529556.png)

![image-20210526155606994](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526155606994.png)

![image-20210526165033401](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526165033401.png)

## 6.箭头函数

使用场景：当一个函数作为另外一个函数参数时

![image-20210526171238753](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526171238753.png)

### 箭头函数中的this

![image-20210526172552966](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526172552966.png)

**总结：箭头函数中的this引用的是最近作用域中的this**

​										向外层作用域中，一层层查找this，直到有this的定义。

![image-20210526172807605](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210526172807605.png)

# vue-cli222

webpack的高度封装

### Vue-Cli 4.x目录结构学习总结

https://blog.csdn.net/qq_40298902/article/details/107352869

## 目录详解

![img](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\20200715094022796.png)

![image-20210524211833484](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210524211833484.png)

### 1.main.js

入口文件

![在这里插入图片描述](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\20200715100637111.png)

浏览器一开始加载就是加载main.js，其中里面通过import的方式引入了各种资源，然后新建了一个vue实例，这个是核心

其中，router和store可以不用去看，重点在render和$mount，

```vue
//这是ES6的箭头函数的写法,可以进入一部化简为下面的写法
render: h => h(App) 
       ||
//可以看到其实就是一个函数，这个函数用来渲染组件(App.vue)的，h()里面可以传入任意想渲染的组件
render (h){     
    return h(App);
}

```

总之记住一句话，render: h => h(App) 是用来渲染组件的，h()里面可以传入任意想渲染的组件

然后是$mount(’#app’)，这个是挂载数据用的，将组件挂载到id为#app的地方，主要在public下的index.html，其中< div id=“app”>将会被组件替换掉，即所谓的挂载

简单的总结:
	通俗的来讲，**新建vue实例的那段代码就是将App.vue下的< template></template>**中间的html代码渲染完之后替代public下的	index.html中id为app的html片段，怎么证明呢，我们可以试着自己写一个测试组件，并且让它渲染我们写的测试组件，不要渲染根组件

### 2.App.vue

App.vue是项目的根组件，所以项目一加载就会通过main.js渲染并挂载App.vue，查看App.vue的代码发现其实跟传统的html差不了多少，都是html+css+js，那么又一个问题，页面跳转怎么搞，这就需要用到页面路由router配置，可以看到App.vue里面引用了< router-view/>路由

## 可视化界面

> vue ui

## wechat

new Vue({

 render: h => h(App),

})**.$mount('#app')**	//挂载

![image-20210525211237855](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210525211237855.png)

地址必须要用require包起来，否则服务器找不到，，在线地址不用包

<style scoped lang="scss">
</style>

这样css样式就是局部的

### 1. 点击修改内容功能

# 路由

路由器提供了两种机制: 路由和转送.
	路由是决定数据包从来源到目的地的路径.
	转送将输入端的数据转移到合适的输出端.

路由中有一个非常重要的概念叫路由表.
	路由表本质上就是一个映射表, 决定了数据包的指向.

## 1.前端渲染后端渲染和前端路由后端路由

### 1.1后端渲染、后端路由//后端阶段

页面直接在后端渲染完，直接给页面叫后端渲染；映射关系也是直接由后端处理叫后端路由

但是, 一个网站, 这么多页面服务器如何处理呢?
	一个页面有自己对应的网址, 也就是URL.
	URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且	最后交给一个Controller进行处理.
	Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.
	这就完成了一个IO操作.

上面的这种操作, 就是后端路由.
	当我们页面中需要请求不同的**路径**内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿.
	这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.

后端路由的缺点:
	一种情况是整个页面的模块由后端人员来编写和维护的.
	另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.
	而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.

![01-后端路由阶段](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\01-后端路由阶段.png)

### 1.2前后端分离阶段

随着Ajax的出现, 有了前后端分离的开发模式.

后端只提供**API来返回数据**, 前端通过**Ajax获取数据**, 并且可以通过**JavaScript将数据渲染到页面**中.

这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.

并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.
目前很多的网站依然采用这种模式开发.

![02-前端后端分离阶段](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\02-前端后端分离阶段.png)

输入一个网址、进入一个网页，页面首先会将html+css+js拿下来，然后再进行接下来的步骤、请求具体的数据

### 1.3单页面富应用阶段（前端路由界面）

其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由.
也就是前端来维护一套路由规则.

![03-SPA页面页面的阶段](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\03-SPA页面页面的阶段.png)

整个网页只有一个html页面-、HTML、css、js资源全部现在下来--》每一个模块（url）打开后，去js中找对应的加载、渲染出来----》一个url对应一个组件（页面）

这种映射关系（**url与页面的映射关系**）就是前端路由在管理 

### 1.4前端路由的核心是什么呢？

改变URL，但是页面不进行整体的刷新。
如何实现呢？

## 2.url的hash和HTML5的history

改变url时让页面并不会刷新

### 2.1改变url上的hash

location.hash='aaa'

### 2.2HTML5的history

#### 1.pushState

history.pushState( { } , '  ' , ' home ' )

history.pushState( { } , '  ' , ' about' )

类似于一个栈结构---》先进后出，所以**history.back()**,从栈顶返回下来

#### 2.replaceState

没有历史记录，不能返回

#### 3.go

history.go(-1)   ===  history.back()

要在push的基础上才能go,可以正数、负数

#### 4.back、forword

## 3.安装和使用vue-router

步骤一: 安装vue-router

> npm install vue-router --save

步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能)

第一步：导入路由对象，并且调用 Vue.use(VueRouter)

第二步：创建路由实例，并且传入路由映射配置

![image-20210527200155394](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527200155394.png)

第三步：在Vue实例中挂载创建的路由实例

![image-20210527200228444](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527200228444.png)

### 使用vue-router的步骤:

第一步: 创建路由组件

![image-20210527200412837](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527200412837.png)

第二步: 配置路由映射: 组件和路径映射关系

![image-20210527200430681](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527200430681.png)

第三步: 使用路由: 通过<router-link>和<router-view>

![image-20210527200446884](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527200446884.png)

<router-link>: 该标签是一个vue-router中已经内置的组件, **它会被渲染成一个<a>标签**.
<router-view>: 该标签会根据当前的路径, 动态渲染出不同的组件.
网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<router-view>处于同一个等级.
在路由切换时, 切换的是<router-view>挂载的组件, 其他内容不会发生改变.

### 最终效果

![image-20210527200516075](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527200516075.png)

### 4.1路径默认值

![image-20210527203742699](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527203742699.png)

redirect：：当进入时，不用点击，直接跳转到home----》缺省时

#### 4.1.1HTML5的History模式

改变路径的方式有两种:
	URL的hash
	HTML5的history

默认情况下, 路径的改变使用的URL的hash.
如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可:

![image-20210527204254160](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527204254160.png)

![image-20210527204334142](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527204334142.png)

### 5.router-link补充

在前面的<router-link>中, 我们只是使用了一个属性: to, 用于指定跳转的路径.

<router-link>还有一些其他属性:

​	**tag**: tag可以指定<router-link>之后渲染成什么组件, 比如上面的代码会被渲染成一个<li>元素, 而不是<a>

![image-20210527205818487](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527205818487.png)

​	**replace**: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中

<router-link to='/home' replace>

​	! ! ! **active-class:** 当<router-link>对应的路由匹配成功时, 会自动 给当前元素设置一个**router-link-active**的class, 设置active-class可以修改默认的名称.
​		在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类.
但是通常不会修改类的属性, 会直接使用默认的router-link-active即可. ![image-20210527205832533](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527205832533.png)

#### 5.1修改linkActiveClass

![image-20210527210541865](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527210541865.png)

![image-20210527210601890](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527210601890.png)

### 6.路由跳转的另外一种方式

![image-20210527210855262](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527210855262.png)

## 4.动态路由的使用

在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：
/user/aaaa或/user/bbbb
除了有前面的/user之外，后面还跟上了用户的ID
这种path和Component的匹配关系，我们称之为**动态路由**(也是路由传递数据的一种方式)。

![image-20210527215003108](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527215003108.png)

![image-20210527220423914](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527220423914.png)

![image-20210527220448560](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527220448560.png)

route、router和routes? ? ?

$route---router里的routes里谁活跃就指向谁

![image-20210527215729527](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527215729527.png)

![image-20210527215750692](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210527215750692.png)

## 5.路由的懒加载

官方给出了解释:
	当打包构建应用时，Javascript 包会变得非常大，影响页面加载。
	**如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了**

官方在说什么呢?
	首先, 我们知道路由中通常会定义很多不同的页面.
	这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中.
	但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大.
	如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了**短暂空白**的情况.
	如何避免这种情况呢? 使用路由懒加载就可以了.

路由懒加载做了什么?
	路由懒加载的主要作用就是**将路由对应的组件打包成一个个的js代码块.**
	只有在这个路由**被访问**到的时候, 才加载对应的组件

### 懒加载效果

![image-20210528162755204](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528162755204.png)

**app**里面放业务代码

**vendor**里面放的是第三方库

### 懒加载方式

方式一: 结合Vue的异步组件和Webpack的代码分析.
![image-20210528162900803](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528162900803.png)

方式二: AMD写法
![image-20210528162908154](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528162908154.png)

方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.

![image-20210528162918719](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528162918719.png)

## 6.路由嵌套

嵌套路由是一个很常见的功能
	比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容.
	一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.

路径和组件的关系如下:

![image-20210528205135003](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528205135003.png)

### 实现嵌套路由有两个步骤:

​	创建对应的子组件, 并且在路由映射中配置对应的子路由.
​	在组件内部使用<router-view>标签.

![image-20210528211352758](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528211352758.png)

![image-20210528211359456](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528211359456.png)

![image-20210528211403728](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528211403728.png)

![image-20210528211410322](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528211410322.png)

## 7.传递参数

我的界面取名---》Profile（档案）

### 1.params的类型:

配置路由格式: /router/:id
传递的方式: 在path后面跟上对应的值
传递后形成的路径: /router/123, /router/abc

第一步: 创建新的组件Profile.vue 

![image-20210528213433885](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528213433885.png)

第二步: 配置路由映射 

![image-20210528213503940](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528213503940.png)

第三步: 添加跳转的<router-link> 

![image-20210528213601220](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528213601220.png)

### 2.query的类型（有大量数据需要传的时候）

配置路由格式: /router, 也就是普通配置
传递的方式: 对象中使用query的key作为传递方式
传递后形成的路径: /router?id=123, /router?id=abc

![image-20210528220012049](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528220012049.png)

![image-20210528220045656](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528220045656.png)

![image-20210528220106186](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528220106186.png)

### 传递参数方式一: <router-link>

![image-20210528220446979](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528220446979.png)

### 传递参数方式二: JavaScript代码

![image-20210528220501614](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528220501614.png)

## 8.$route和$router是有区别的

![image-20210528220908932](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210528220908932.png)

$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法

$route为当前router跳转对象里面可以获取name、path、query、params等 

### **所有组件都继承自Vue的原型**



## 9.全局导航守卫

我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢?
	网页标题是通过<title>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变.
	但是我们可以通过JavaScript来修改<title>的内容.window.document.title = '新的标题'.
	那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?

### 普通的修改方式:

​	我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中.
​	通过mounted声明周期函数, 执行对应的代码进行修改即可.
​	但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码).

有没有更好的办法呢? 使用导航守卫即可.

### 什么是导航守卫?

​	vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.
​	vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.

### 导航守卫的使用

我们可以利用beforeEach来完成标题的修改.
	首先, 我们可以在钩子当中定义一些标题, 可以利用meta来定义
	其次, 利用导航守卫,修改我们的标题.

### 前置钩子

![image-20210529102456931](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210529102456931.png)



![image-20210529102539799](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210529102539799.png)

 document.title = to.matched[0].meta.title;=======》中matched[0]的作用：只匹配第一个，显示孩子的路径标题也是父亲的标题

【注意】：：必须要调用next，否则不会进行下一步

导航钩子的三个参数解析:
	to: 即将要进入的目标的路由对象.
	from: 当前导航即将要离开的路由对象.
	next: 调用该方法后, 才能进入下一个钩子.

### 补充

补充一:如果是后置钩子, 跳转后回调，，也就是afterEach, 不需要主动调用next()函数.======》之前是前置钩子（回调），跳转前回调的

补充二: 上面我们使用的导航守卫, 被称之为全局守卫.
路由独享的守卫.！！！  拦截器，权限，，比如必须要登录了 才能访问，可以直接给跳转到登录页面
组件内的守卫.

## 10.keep-alive遇见vue-router

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
	它们有两个非常重要的属性:
		**include** - 字符串或正则表达，只有匹配的组件会被缓存
		**exclude** - 字符串或正则表达式，任何匹配的组件都不会被缓存

router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：

![image-20210529104331204](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210529104331204.png)

通过create声明周期函数来验证

activated() 与deactivated() 只与<keep-alive></keep-alive>有关，，被保持了状态 ，，，

因为在app.vue 使用keep-alive ，所以about等都会被保持状态，不会频繁被创建、销毁，只会活跃，或者不活跃，，

如果不想一直keep-alive=====><keep-alive exclude="Profile,User"></keep-alive>,但是User前面不可有空格

# TabBar

**在style中引入样式**：@import url("./assets/css/base.css");------->但是子组件里面不可以用

## 插槽的坑

![image-20210529214540464](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210529214540464.png)

 <!-- v-slot:插槽名，可简写为#插槽名 -->，必须包裹在template里面

![image-20210529214720607](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210529214720607.png)

在这儿里面却用slot标签

因为插槽是整体替换的，所以要在外面包裹一个div才能用v-bind

## TabBarItem颜色动态控制

![image-20210530095251618](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095251618.png)

绑定判断后使用计算属性

![image-20210530095324772](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095324772.png)

## 路由流程

### 1.index.js

![image-20210530095441002](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095441002.png)

### 2.app.vue

![image-20210530095522247](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095522247.png)

### 3.TabBarItem.vue

监听点击事件，然后改变路径

![image-20210530095605126](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095605126.png)

，这里的path通过父传子pops,从app。vue传过来

![image-20210530095748154](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095748154.png)

![image-20210530095834024](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530095834024.png)

## 封装字体颜色

![image-20210530100921826](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530100921826.png)

![image-20210530100940894](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530100940894.png)

![image-20210530101022864](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530101022864.png)

## 文件路径引用问题

如果很难定位我要找的文件的相对路径

可以从src开始找绝对路径

src="src/assets/img/tabbar/home.svg"=====src="../assets/img/tabbar/home.svg"

# Vuex

## Vuex是做什么的？

官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。
	它采用 **集中式存储管理** 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
	Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

**状态管理**到底是什么？
	**状态管理模式、集中式存储管理**这些名词听起来就非常高大上，让人捉摸不透。
	其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。
	然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。
	那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？

等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？
	当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是**响应式**。
	如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。
	不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。

### 管理什么状态呢？

但是，有什么状态时需要我们在多个组件间共享的呢？
	如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。
	比如用户的登录状态、用户名称、头像、地理位置信息等等。
	比如商品的收藏、购物车中的物品等等。
	这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的（待会儿我们就可以看到代码了，莫着急）。

## 单界面的状态管理

我们知道，要在单个组件中进行状态管理是一件非常简单的事情
什么意思呢？我们来看下面的图片。

![image-20210530192917035](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530192917035.png)

这图片中的三种东西，怎么理解呢？
	State：不用多说，就是我们的**状态**。（你姑且可以当做就是data中的属性）
	View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）
	Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。

![image-20210530194517255](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530194517255.png)

在这个案例中，我们有木有状态需要管理呢？没错，就是个数counter。

**counter需要某种方式被记录下来，也就是我们的State。**

**counter目前的值需要被显示在界面中，也就是我们的View部分。**

**界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions**

这不就是上面的流程图了吗？

## 多页面状态管理

Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？
	多个视图都依赖同一个状态（一个状态改了，多个界面需要进行更新）
	不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）

也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个视图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的
	状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。
	但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！
	没错，Vuex就是为我们提供这个大管家的工具。

**全局单例模式（大管家）**
	我们现在要做的就是将**共享的状态抽取**出来，交给我们的大管家，统一进行管理。
	之后，你们每个试图，按照我**规定好的**规定，进行访问和修改等操作。
这就是Vuex背后的基本思想。

### vuex安装

npm install vuex --save

### Vuex状态管理图例

![image-20210530203759322](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530203759322.png)

- [x] devtools：记录Vuex中每次state修改的状态（跟踪），，
- [x] 所以components不能直接反过来修改stare，可以直接修改mutations，再修改state，这样方便devtools跟踪，，
- [x] 如果是异步操作，必须要经过Action那条线

`backend：后端`

`fronend：前端`



## Vuex核心概念

### devtools和mutations

![image-20210530211227283](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530211227283.png)

#### mutations里面放方法

全局的methods

![image-20210530211629739](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530211629739.png)

![image-20210530212029999](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530212029999.png)

实现后：

![image-20210530212138063](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210530212138063.png)

#### 使用Vuex的count

好的，这就是使用Vuex最简单的方式了。
我们来对使用步骤，做一个简单的小节：
	1.提取出一个公共的store对象，用于保存在多个组件中共享的状态
	2.将**store对象放置在new Vue对象**中，这样可以保证在所有的组件中都可以使用到
	3.在其他组件中使用store对象中保存的状态即可
		****通过this.$store.state.属性的方式来访问状态**
		通过this.$store.commit('mutation中方法')来修改状态**

注意事项：
	我们通过提交mutation的方式，而非直接改变store.state.count。
	这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。

#### Mutation状态更新

Vuex的store状态的**更新唯一方式**：提交Mutation
Mutation主要包括两部分：
	字符串的事件类型（type）
	一个回调函数（handler）,该回调函数的第一个参数就是state。

![image-20210531092912850](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531092912850.png)mutation的定义方式：

![image-20210531092942726](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531092942726.png)

通过mutation更新

![image-20210531092951761](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531092951761.png)

#### Mutation传递参数

在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数
参数被称为是mutation的**载荷(Payload)**

![image-20210531093629538](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531093629538.png)

![image-20210531093744033](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531093744033.png)

mutation中的代码（与getter传递参数不同，可以直接放在里面作为参数传递）

![image-20210531093804656](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531093804656.png)

#### 多参数传递

比如我们有很多参数需要传递.
这个时候, 我们通常会以对象的形式传递, 也就是payload是一个对象.
这个时候可以再从对象中取出相关的信息.

![image-20210531094835709](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531094835709.png)

![image-20210531095739959](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531095739959.png)

![image-20210531095756242](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531095756242.png)

#### 特殊提交风格

上面的通过commit进行提交是一种普通的方式
Vue还提供了另外一种风格, 它是一个**包含type属性**的对象

原理对应Mutation状态更新里面的（Mutation主要包括两部分）

![image-20210531100013672](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531100013672.png)

Mutation中的处理方式是将整个commit的对象作为payload使用, 所以代码没有改变,

![image-20210531100451084](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531100451084.png)

#### Mutation常量类型 – 概念

我们来考虑下面的问题:
	在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).
	当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.
	方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.

如何避免上述的问题呢?
	在各种Flux实现中, 一种很常见的方案就是使用常量替代Mutation事件的类型.
	我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.

具体怎么做呢?
	我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.
	定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.

![image-20210531104319971](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531104319971.png)

#### Mutation同步函数

通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.
	主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.
	但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.
	比如我们之前的代码, 当执行更新时, devtools中会有如下信息: 图1

![image-20210531104952470](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531104952470.png)

但是, 如果Vuex中的代码, 我们使用了异步函数: 图2

![image-20210531104958408](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531104958408.png)

你会发现state中的info数据一直没有被改变, 因为他无法追踪到.
So, 通常情况下, 不要再mutation中进行异步的操作

要异步操作======》使用Action

### State

相当于全局的data

#### State单一状态数

Vuex提出使用单一状态树, 什么是单一状态树呢？
	英文名称是Single Source of Truth，也可以翻译成单一数据源。

但是，它是什么呢？我们来看一个生活中的例子。
	OK，我用一个生活中的例子做一个简单的类比。
	我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工  作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。
	这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。
	这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。

这个和我们在应用开发中比较类似：
	如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。
	所以Vuex也使用了**单一状态树来管理应用层级的全部状态**。
	单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。

**Vuex只推荐使用一个store**

### Getters

其实就相当于全局计算属性computed 

![image-20210531092407688](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531092407688.png)

![image-20210531092124547](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531092124547.png)

#### Getters作为参数和传递参数

getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.
比如上面的案例中,我们希望根据ID获取用户的信息

![image-20210531092534901](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531092534901.png)

### 

### Action

Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.

Action的基本使用代码如下:

![image-20210531105345719](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531105345719.png)

**context是什么?**
	context是和store对象具有相同方法和属性的对象.
	也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.
	但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候, 再具体说.

这样的代码是否多此一举呢?
	我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?
	事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了.

但是注意修改state的唯一方式是通过Mutation，不能因为是异步操作就跳过mutation直接，，再次看图

![image-20210531183336946](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531183336946.png)

在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch

![image-20210601170717898](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210601170717898.png)

同样的, 也是支持传递payload（传递参数）

![image-20210601170811634](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210601170811634.png)

#### action返回的promise

![image-20210601171328705](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210601171328705.png)

### Module

Module是模块的意思, 为什么在Vuex中我们要使用模块呢?
	Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.
	当应用变得非常复杂时,store对象就有可能变得相当臃肿.
	为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等

![image-20210601171550346](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210601171550346.png)

![image-20210601173328455](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210601173328455.png)

![image-20210601173351429](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210601173351429.png)

还是单一状态树，不过是合并了

### Actions写法

#### 对象解构

<img src="C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210612205754460.png" alt="image-20210612205754460" style="zoom: 80%;" /><img src="C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210612205815141.png" alt="image-20210612205815141" style="zoom: 80%;" />

顺序可以换

#### 重构代码



## 数据的响应式

设计了双向数据绑定的原理

这些属性都会被加入到响应式奈统中。而响应式系统会监听属性的变化，当属性发生变化时,会通知所有界面中用到该属性的地方,让界面发生刷新；

Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.
这就要求我们必须遵守一些Vuex对应的规则:
	提前在store中初始化好所需的属性.
	当给state中的对象添加新属性时, 使用下面的方式:
		方式一: 使用Vue.set(obj, 'newProp', 123)
		方式二: 用新对象给旧对象重新赋值

我们来看一个例子:
	当我们点击更新信息时, 界面并没有发生对应改变.（现在可以发生改变了）
	如何才能让它改变呢?
		查看下面代码的方式一和方式二
		都可以让state中的属性是响应式的.

![image-20210531101732092](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531101732092.png)

### 数组中响应式的方法

![image-20210531102031548](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210531102031548.png)









npm install -g less

lessc -version

# 网络模块封装

## 1.axios

### 为什么选择axios？

功能特点:

在浏览器中发送 XMLHttpRequests 请求
在 node.js 中发送 http请求
支持 Promise API
拦截请求和响应
转换请求和响应数据

### axios请求方式

支持多种请求方式:
axios(config)
axios.request(config)
axios.get(url[, config])
axios.delete(url[, config])
axios.head(url[, config])
axios.post(url[, data[, config]])
axios.put(url[, data[, config]])
axios.patch(url[, data[, config]])



```
npm install axios --save
```

httpbin.org/模拟端口

![image-20210613084313298](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613084313298.png)

支持promise，就不用写.get之类的语句,直接.then

```html
axios({
  url: "http://123.207.32.32:8000/home/multidata",
}).then((res) => {
  console.log(res);
});
```

默认是get请求，想要改变：method:post

防止跨域

![image-20210613084409556](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613084409556.png)

```
123.207.32.32:8000/home/data?type=sell&page=3
```

 专门针对get请求的参数拼接 

```
url: "http://123.207.32.32:8000/home/data?type=sell&page=3",

 params: {
  	type: "pop",

  	page: 1,
  }
```

### axios发送并发请求

两个请求都拿到结果后再去完成对应的事情

有时候, 我们可能需求同时发送两个请求
使用axios.all, 可以放入多个请求的数组.
	axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2

超时设置：timeout:5

axios . all ( [ axios() , axios() ] ) . then( results =>{})

![image-20210613090545866](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613090545866.png)

方法二：分别去数组里面的两个axios

![image-20210613090837672](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613090837672.png)

### 全局相关配置：

![image-20210613111812417](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613111812417.png)

创建相关配置

请求地址
url: '/user',

请求类型
method: 'get',

请根路径
baseURL: 'http://www.mt.com/api',

**请求前的数据处理**
**transformRequest:[function(data){}],**

请求后的数据处理
transformResponse: [function(data){}],

自定义的请求头
headers:{'x-Requested-With':'XMLHttpRequest'},

URL查询对象**（必须针对get请求）**
params:{ id: 12 },

查询对象序列化函数
paramsSerializer: function(params){ }

request body
data: { key: 'aa'},

超时设置s
timeout: 1000,

跨域是否带Token
withCredentials: false,

自定义请求处理
adapter: function(resolve, reject, config){},

身份验证信息
auth: { uname: '', pwd: '12'},

响应的数据格式 json / blob /document /arraybuffer / text / stream
responseType: 'json',

![image-20210613112458374](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613112458374.png)

## 2.axios实例

### 为什么要创建axios的实例呢?

当我们从axios模块中导入对象时, 使用的实例是默认的实例.
当给该实例设置一些默认配置时, 这些配置就被固定下来了.
但是后续开发中, 某些配置可能会不太一样.
比如某些请求需要使用特定的baseURL或者timeout或者content-Type等.
这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.

category：分类

在开发中为了应对服务器以后不在同一个 ip地址里面-----》axios实例

instance：：实例

![image-20210613153600429](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613153600429.png)

## 3.封装

![image-20210613154233099](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613154233099.png)![image-20210613154244229](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613154244229.png)

对第三方框架依赖太大，如果框架不再维护，需要替换掉，工程很大-----》单独搞一个文件，在文件里面搞封装

### 方法一（回调函数方式）

不用default而用function的原因是接口不止一个。。

![image-20210613165043783](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613165043783.png)

![image-20210613165116284](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613165116284.png)

调用

![image-20210613165216689](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613165216689.png)

### 方法二（promise方式）

![image-20210613165557996](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613165557996.png)

调用

![image-20210613165640752](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613165640752.png)

### 最终方案

可以直接return的原因：：create底层本身就是一个promise

![image-20210613165924799](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613165924799.png)

![image-20210613170347259](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613170347259.png)

调用方法不变



# GitHub建

# 仓库

![image-20210613091926743](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613091926743.png)

不选择redme，因为项目里面有，会冲突

![image-20210613092215893](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613092215893.png)

![image-20210613092326498](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613092326498.png)

许可协议一般选择MIT，别人可以用

将地址克隆

![image-20210613092631129](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613092631129.png)

git status:脱管状态

git add .:将所有东西加进来

git commit -m '初始化项目'-----》这是提交到本地

git push :提交到服务器

## 配置

![image-20210613102909634](C:\Users\zyy\Desktop\Practical project Note\VueStudy\事件绑定.assets\image-20210613102909634.png)123456



